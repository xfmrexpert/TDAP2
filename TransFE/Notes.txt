StiffnessContributor does a lot of the heavy lifting for specific formulations of the stiffness matrix.  It is a base class that is inherited by the various 
formulation-specific implementations.


StiffnessContributor presently handles integration in the evaluate method.  This is a generic routine, with formulation specific details handled in the EvaluatePt
method.  This method evaluates the stiffness matrix at a given point in the element.  The stiffness matrix is a (nnd * nen) x (nnd * nen) matrix, with nen being the number of nodes
in the element and nnd being the number of DOFs/node.  The sum of the stiffness matrices at each point is accumulated in the element stiffness matrix.  The stiffness matrix is then 
multiplied by the integration weight and the determinant of the Jacobian to get the contribution to the global stiffness matrix.

Nodes are essentially DOF containers.  Nodes are generally located at each vertex, but can be located on edges or faces.  We need to come up with a way to handle complex DOFs. We
could treat real and imaginary parts as separate DOFs, but that might make the accounting of DOFs and global stiffness matrix locations more difficult.  A complex DOF would mean the
local to global node numbering would be the same as for real DOFS.  The problem, I think, with complex DOFs is sorting out how to do that without a proliferation of template parameters 
all over the place.

void Mesh::reorder2() {
	size_t labeldof = 0;
	for (const auto& node : Nodes) {
		const auto& DOFs = node->getDOFs();
		for (const auto& dof : DOFs) {
			if (dof->get_status() == DOFStatus::Free) {
				dof->set_eqnumber(labeldof);
				labeldof++;
			}
		}
	}
};

void Mesh::reorder() {
	size_t labeldof = ndof;
	size_t labelnode = Nodes.size();
	size_t labelface = MeshFaces.size();
	size_t labelregion = MeshRegions.size();

	std::queue<MeshEntity*> q;
	std::queue<MeshEntity*> list;

	//cout << "Beginning mesh reordering...\n";

	for (const auto& node : Nodes) {
		node->setID(-2); //-2 indicates not labeled and not in queue
	}
	for (const auto& face : MeshFaces) {
		face->setID(-2); //-2 indicates not labeled and not in queue
	}
	for (const auto& region : MeshRegions) {
		region->setID(-2); //-2 indicates not labeled and not in queue
	}

	//cout << "Get start...\n";

	MeshEntity* entity = getStart();
	//cout << "Put first entity into queue...\n";
	q.push(entity);
	entity->setID(-1); //0 indicates entity in queue
	//cout << "Begin looping through queue...\n";
	while (q.size() > 0) {
		if (labelnode < 0) {
			std::cout << "ERROR! labelnode<0!\n";
			return;
		}
		entity = q.front();
		q.pop();
		//if(entity->get_dimensions()==1){cout << "dequeueing edge\n";}
		auto node = entity->getNode();
		if (node->getID() < 0) { //node is unlabeled
			labelnode = labelnode - 1;
			node->setID(labelnode);
			const auto& DOFs = node->getDOFs();
			for (const auto& dof : DOFs) {
				if (dof->get_status() == DOFStatus::Free) {
					labeldof = labeldof - 1;
					if (labeldof < 0) {
						std::cout << "ERROR! labeldof<0!\n";
						return;
					}
					dof->set_eqnumber(labeldof);
				}
			}
		}

		if (entity->get_dimensions() == 0) { //entity is a vertex
			//cout << "Loop through edges of vertex\n";
			MeshVertex* vertex = dynamic_cast<MeshVertex*>(entity);
			for (const auto& edge : vertex->Edges()) {
				//cout << "Loop through faces of edge #" << edge->ID << "\n";
				for (const auto& face : edge->Faces()) {
					if (face->getID() < 0) { //face is unlabeled
						labelface = labelface - 1;
						face->setID(labelface);
					}
					if (face->getNode() != nullptr && face->getNode()->getID() < -1) {
						q.push(face);
						face->getNode()->setID(-1);
					}
				}
				auto othervertex = edge->otherVertex(*vertex);
				if (edge->getNode() != nullptr) {  //if edge has a node
					//cout << "Edge has a node\n";
					if (othervertex->getNode()->getID() >= -1 && edge->getNode()->getID() < -1) {
						//cout << "Labeling node directly\n";
						labelnode = labelnode - 1;
						edge->getNode()->setID(labelnode);
						const auto& DOFs = edge->getNode()->getDOFs();
						for (const auto& dof : DOFs) {
							if (dof->get_status() == DOFStatus::Free) {
								labeldof = labeldof - 1;
								if (labeldof < 0) {
									std::cout << "ERROR! labeldof<0!\n";
									return;
								}
								dof->set_eqnumber(labeldof);
							}
						}
					}
					else if (othervertex->getNode()->getID() < -1) {
						//cout << "Queueing edge\n";
						q.push(edge);
						list.push(othervertex);
						othervertex->getNode()->setID(-1);
					}
				}
				else {
					if (othervertex->getNode()->getID() < -1) {
						//cout << "Queue edge's other vertex\n";
						list.push(othervertex);
						othervertex->getNode()->setID(-1);
					}
				}
			}
		}
		while (list.size() > 0) {
			//cout << "Queue list\n";
			q.push(list.front());
			list.pop();
		}
		//cout << "Get next entity...\n";
	}
	std::cout << labelnode;
}

// Function to get non-owning pointers to DOFs
std::vector<DOF*> Node::getDOFs() const {
	std::vector<DOF*> result;
	result.reserve(DOFs.size()); // Reserve space for efficiency
	for (const auto& dof : DOFs) {
		result.push_back(dof.get()); // Extract raw pointer
	}
	return result; // Return non-owning pointers
}

DOF* Node::newDOF() {
	DOFs.push_back(std::make_unique<DOF>());
	return DOFs.back().get();;
}

